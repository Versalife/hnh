%%%
import "@nota-lang/nota-theme-acm/dist/index.css"
import bibtex from "./bibliography.bib"
import _ from "lodash";

let sysname = @Smallcaps{Flowistry};
%%%


@Title: Interpreting Neural Networks

@Authors:
  @Author: @Name{Okonda, Joseph L}
@Abstract:
  To understand the mechanisms underlying a trait exhibited by some complex system, we should study similar systems lacking that trait. Doing so allows us to locate and isolate components of the system that are most responsible for the trait in question. Once  isolated, we can further probe those components to better understand their mechanism of action. This general principle has been applied to great success in molecular biologyâ€™s study of biological black boxes (i.e. organisms and the cells that comprise them) Can we deploy this general framework to design and analyse experiments to interpreting trained Neural Networks?


@Section[name: "sec_intro"]: Introduction
Information flow describes how data influences other data within a program. Information flow has applications to security, such as information flow control &sabelfeld2003language, and to developer tools, such as program slicing &weiser1984program. Our goal is to build a practical system for analyzing information flow, meaning:

* **Applicable to common language features:** the language being analyzed  should support widely used features like pointers and in-place mutation.
* **Zero configuration to run on existing code:** the analyzer must integrate with an existing language and existing unannotated programs. It must not require users to adopt a new language designed for information flow.
* **No dynamic analysis:** to reduce integration challenges and costs, the analyzer must be purely static --- no modifications to runtimes or binaries are needed.
* **Modular over dependencies:** programs may not have source available for dependencies. The analyzer must have reasonable precision without whole-program analysis.
  
As a case study on the challenges imposed by these requirements, consider analyzing the information that flows to the return value in this C++ function:


@Authors:
  @Author: @Name{September 23 2023}


```
// Copy elements 0 to max into a new vector
vector<int> copy_to(vector<int>& v, size_t max) {
  vector<int> v2; size_t i = 0;
  for (auto x(v.begin()); x != v.end(); ++x) {
    if (i == max) { break; }
    v2.push_back(*x); ++i;
  }
  return v2;
}
```

Here, a key flow is that `v2` is influenced by `v`: (1) `push_back` mutates `v2` with `*x` as input, and (2) `x` points to data within `v`. But how could an analyzer statically deduce these facts? For C++, the answer is *by looking at function implementations*. The implementation of `push_back` mutates `v2`, and the implementation of `begin` returns a pointer to data in `v`.

However, analyzing such implementations violates our fourth requirement, since these functions may only have their type signature available. In C++, given only a function's type signature, not much can be inferred about its behavior, since the type system does not contain information relevant to pointer analysis.

Our key insight is that *ownership types* can be leveraged to modularly analyze pointers and mutation using only a function's type signature. Ownership has emerged from several intersecting lines of research on linear logic &girard1987linear, class-based alias management &clarke1998ownership, and region-based memory management &grossman2002region. The fundamental law of ownership is that data cannot be simultaneously aliased and mutated. Ownership-based type systems enforce this law by tracking which entities own which data, allowing ownership to be transferred between entities, and flagging ownership violations like mutating immutably-borrowed data.

Today, the most popular ownership-based language is Rust. Consider the information flows in this Rust implementation of `copy_to`:

```
fn copy_to(v: &Vec<i32>, max: usize) -> Vec<i32> {
  let mut v2 = Vec::new();
  for (i, x) in v.iter().enumerate() {
    if i == max { break; }
    v2.push(*x);
  }
  return v2;
}
```
@References[bibtex]
