<!DOCTYPE html><html lang="en" class=""><head><style>.ͼ1.cm-focused {outline: 1px dotted #212121;}
.ͼ1 {position: relative !important; box-sizing: border-box; display: flex !important; flex-direction: column;}
.ͼ1 .cm-scroller {display: flex !important; align-items: flex-start !important; font-family: monospace; line-height: 1.4; height: 100%; overflow-x: auto; position: relative; z-index: 0;}
.ͼ1 .cm-content[contenteditable=true] {-webkit-user-modify: read-write-plaintext-only;}
.ͼ1 .cm-content {margin: 0; flex-grow: 2; flex-shrink: 0; display: block; white-space: pre; word-wrap: normal; box-sizing: border-box; padding: 4px 0; outline: none;}
.ͼ1 .cm-lineWrapping {white-space: pre-wrap; white-space: break-spaces; word-break: break-word; overflow-wrap: anywhere; flex-shrink: 1;}
.ͼ2 .cm-content {caret-color: black;}
.ͼ3 .cm-content {caret-color: white;}
.ͼ1 .cm-line {display: block; padding: 0 2px 0 6px;}
.ͼ1 .cm-layer > * {position: absolute;}
.ͼ1 .cm-layer {position: absolute; left: 0; top: 0; contain: size style;}
.ͼ2 .cm-selectionBackground {background: #d9d9d9;}
.ͼ3 .cm-selectionBackground {background: #222;}
.ͼ2.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground {background: #d7d4f0;}
.ͼ3.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground {background: #233;}
.ͼ1 .cm-cursorLayer {pointer-events: none;}
.ͼ1.cm-focused > .cm-scroller > .cm-cursorLayer {animation: steps(1) cm-blink 1.2s infinite;}
@keyframes cm-blink {50% {opacity: 0;}}
@keyframes cm-blink2 {50% {opacity: 0;}}
.ͼ1 .cm-cursor, .ͼ1 .cm-dropCursor {border-left: 1.2px solid black; margin-left: -0.6px; pointer-events: none;}
.ͼ1 .cm-cursor {display: none;}
.ͼ3 .cm-cursor {border-left-color: #444;}
.ͼ1 .cm-dropCursor {position: absolute;}
.ͼ1.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor {display: block;}
.ͼ2 .cm-activeLine {background-color: #cceeff44;}
.ͼ3 .cm-activeLine {background-color: #99eeff33;}
.ͼ2 .cm-specialChar {color: red;}
.ͼ3 .cm-specialChar {color: #f78;}
.ͼ1 .cm-gutters {flex-shrink: 0; display: flex; height: 100%; box-sizing: border-box; inset-inline-start: 0; z-index: 200;}
.ͼ2 .cm-gutters {background-color: #f5f5f5; color: #6c6c6c; border-right: 1px solid #ddd;}
.ͼ3 .cm-gutters {background-color: #333338; color: #ccc;}
.ͼ1 .cm-gutter {display: flex !important; flex-direction: column; flex-shrink: 0; box-sizing: border-box; min-height: 100%; overflow: hidden;}
.ͼ1 .cm-gutterElement {box-sizing: border-box;}
.ͼ1 .cm-lineNumbers .cm-gutterElement {padding: 0 3px 0 5px; min-width: 20px; text-align: right; white-space: nowrap;}
.ͼ2 .cm-activeLineGutter {background-color: #e2f2ff;}
.ͼ3 .cm-activeLineGutter {background-color: #222227;}
.ͼ1 .cm-panels {box-sizing: border-box; position: sticky; left: 0; right: 0;}
.ͼ2 .cm-panels {background-color: #f5f5f5; color: black;}
.ͼ2 .cm-panels-top {border-bottom: 1px solid #ddd;}
.ͼ2 .cm-panels-bottom {border-top: 1px solid #ddd;}
.ͼ3 .cm-panels {background-color: #333338; color: white;}
.ͼ1 .cm-tab {display: inline-block; overflow: hidden; vertical-align: bottom;}
.ͼ1 .cm-widgetBuffer {vertical-align: text-top; height: 1em; width: 0; display: inline;}
.ͼ1 .cm-placeholder {color: #888; display: inline-block; vertical-align: top;}
.ͼ1 .cm-highlightSpace:before {content: attr(data-display); position: absolute; pointer-events: none; color: #888;}
.ͼ1 .cm-highlightTab {background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>'); background-size: auto 100%; background-position: right 90%; background-repeat: no-repeat;}
.ͼ1 .cm-trailingSpace {background-color: #ff332255;}
.ͼ1 .cm-button {vertical-align: middle; color: inherit; font-size: 70%; padding: .2em 1em; border-radius: 1px;}
.ͼ2 .cm-button:active {background-image: linear-gradient(#b4b4b4, #d0d3d6);}
.ͼ2 .cm-button {background-image: linear-gradient(#eff1f5, #d9d9df); border: 1px solid #888;}
.ͼ3 .cm-button:active {background-image: linear-gradient(#111, #333);}
.ͼ3 .cm-button {background-image: linear-gradient(#393939, #111); border: 1px solid #888;}
.ͼ1 .cm-textfield {vertical-align: middle; color: inherit; font-size: 70%; border: 1px solid silver; padding: .2em .5em;}
.ͼ2 .cm-textfield {background-color: white;}
.ͼ3 .cm-textfield {border: 1px solid #555; background-color: inherit;}
.ͼn .cm-scroller {font-family: var(--font-mono);}
.ͼn .cm-gutters {background: var(--bg); border: none;}
.ͼn .cm-lineNumbers .cm-gutterElement {font-size: 12px; padding-top: 2px; padding-right: 7px; min-width: 10px;}
.ͼn .cm-highlight {padding: 0 2px; margin: -1px -2px; border-radius: 2px;}
.ͼ4 {color: #404740;}
.ͼ5 {text-decoration: underline;}
.ͼ6 {text-decoration: underline; font-weight: bold;}
.ͼ7 {font-style: italic;}
.ͼ8 {font-weight: bold;}
.ͼ9 {text-decoration: line-through;}
.ͼa {color: #708;}
.ͼb {color: #219;}
.ͼc {color: #164;}
.ͼd {color: #a11;}
.ͼe {color: #e40;}
.ͼf {color: #00f;}
.ͼg {color: #30a;}
.ͼh {color: #085;}
.ͼi {color: #167;}
.ͼj {color: #256;}
.ͼk {color: #00c;}
.ͼl {color: #940;}
.ͼm {color: #f00;}
</style><link href="index.css" rel="stylesheet"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Interpreting Neural Networks</title></head><body><div id="root"><div class="nota-document"><div class="document-title">Interpreting Neural Networks</div><div class="authors"><div class="author"><span class="author-name">Okonda, Joseph L</span></div></div><div class="abstract">To understand the mechanisms underlying a trait exhibited by some complex system, we should study similar systems lacking that trait. Doing so allows us to locate and isolate components of the system that are most responsible for the trait in question. Once  isolated, we can further probe those components to better understand their mechanism of action. This general principle has been applied to great success in molecular biology’s study of biological black boxes (i.e. organisms and the cells that comprise them) Can we deploy this general framework to design and analyse experiments to interpreting trained Neural Networks?</div><section><h1 class="section-title"><div id="def-sec_intro" class="definition"><span class="section-number">1</span> Introduction</div></h1><p>Information flow describes how data influences other data within a program. Information flow has applications to security, such as information flow control <a href="#def-sabelfeld2003language" class="ref"><span class="cite">[<span class="tex"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord text"><span class="mord">Sabelfeld&nbsp;and&nbsp;Myers&nbsp;2003</span></span></span></span></span></span>]</span></a>, and to developer tools, such as program slicing <a href="#def-weiser1984program" class="ref"><span class="cite">[<span class="tex"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord text"><span class="mord">Weiser&nbsp;1981</span></span></span></span></span></span>]</span></a>. Our goal is to build a practical system for analyzing information flow, meaning:</p><ul><li><p><strong>Applicable to common language features:</strong> the language being analyzed  should support widely used features like pointers and in-place mutation.</p></li><li><p><strong>Zero configuration to run on existing code:</strong> the analyzer must integrate with an existing language and existing unannotated programs. It must not require users to adopt a new language designed for information flow.</p></li><li><p><strong>No dynamic analysis:</strong> to reduce integration challenges and costs, the analyzer must be purely static — no modifications to runtimes or binaries are needed.</p></li><li><p><strong>Modular over dependencies:</strong> programs may not have source available for dependencies. The analyzer must have reasonable precision without whole-program analysis.</p></li></ul><p>As a case study on the challenges imposed by these requirements, consider analyzing the information that flows to the return value in this C++ function:</p><div class="authors"><div class="author"><span class="author-name">September 23 2023</span></div></div><div class="listing"><div class="cm-editor ͼ1 ͼ2 ͼn"><div aria-live="polite" style="position: fixed; top: -10000px;"></div><div tabindex="-1" class="cm-scroller"><div class="cm-gutters" aria-hidden="true" style="min-height: 126px; position: sticky;"><div class="cm-gutter cm-lineNumbers"><div class="cm-gutterElement" style="height: 0px; visibility: hidden; pointer-events: none;">9</div><div class="cm-gutterElement" style="height: 14px;">1</div><div class="cm-gutterElement" style="height: 14px;">2</div><div class="cm-gutterElement" style="height: 14px;">3</div><div class="cm-gutterElement" style="height: 14px;">4</div><div class="cm-gutterElement" style="height: 14px;">5</div><div class="cm-gutterElement" style="height: 14px;">6</div><div class="cm-gutterElement" style="height: 14px;">7</div><div class="cm-gutterElement" style="height: 14px;">8</div><div class="cm-gutterElement" style="height: 14px;">9</div></div></div><div spellcheck="false" autocorrect="off" autocapitalize="off" translate="no" contenteditable="false" class="cm-content" role="textbox" aria-multiline="true" style="tab-size: 4;"><div class="cm-line">// Copy elements 0 to max into a new vector</div><div class="cm-line">vector&lt;int&gt; copy_to(vector&lt;int&gt;&amp; v, size_t max) {</div><div class="cm-line">  vector&lt;int&gt; v2; size_t i = 0;</div><div class="cm-line">  for (auto x(v.begin()); x != v.end(); ++x) {</div><div class="cm-line">    if (i == max) { break; }</div><div class="cm-line">    v2.push_back(*x); ++i;</div><div class="cm-line">  }</div><div class="cm-line">  return v2;</div><div class="cm-line">}</div></div></div></div></div><p>Here, a key flow is that <code>v2</code> is influenced by <code>v</code>: (1) <code>push_back</code> mutates <code>v2</code> with <code>*x</code> as input, and (2) <code>x</code> points to data within <code>v</code>. But how could an analyzer statically deduce these facts? For C++, the answer is <em>by looking at function implementations</em>. The implementation of <code>push_back</code> mutates <code>v2</code>, and the implementation of <code>begin</code> returns a pointer to data in <code>v</code>.</p><p>However, analyzing such implementations violates our fourth requirement, since these functions may only have their type signature available. In C++, given only a function's type signature, not much can be inferred about its behavior, since the type system does not contain information relevant to pointer analysis.</p><p>Our key insight is that <em>ownership types</em> can be leveraged to modularly analyze pointers and mutation using only a function's type signature. Ownership has emerged from several intersecting lines of research on linear logic <a href="#def-girard1987linear" class="ref"><span class="cite">[<span class="tex"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord text"><span class="mord">Jean-Yves&nbsp;Girard&nbsp;1987</span></span></span></span></span></span>]</span></a>, class-based alias management <a href="#def-clarke1998ownership" class="ref"><span class="cite">[<span class="tex"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord text"><span class="mord">Clarke&nbsp;et&nbsp;al.&nbsp;1998</span></span></span></span></span></span>]</span></a>, and region-based memory management <a href="#def-grossman2002region" class="ref"><span class="cite">[<span class="tex"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord text"><span class="mord">Grossman&nbsp;et&nbsp;al.&nbsp;2002</span></span></span></span></span></span>]</span></a>. The fundamental law of ownership is that data cannot be simultaneously aliased and mutated. Ownership-based type systems enforce this law by tracking which entities own which data, allowing ownership to be transferred between entities, and flagging ownership violations like mutating immutably-borrowed data.</p><p>Today, the most popular ownership-based language is Rust. Consider the information flows in this Rust implementation of <code>copy_to</code>:</p><div class="listing"><div class="cm-editor ͼ1 ͼ2 ͼn"><div aria-live="polite" style="position: fixed; top: -10000px;"></div><div tabindex="-1" class="cm-scroller"><div class="cm-gutters" aria-hidden="true" style="min-height: 112px; position: sticky;"><div class="cm-gutter cm-lineNumbers"><div class="cm-gutterElement" style="height: 0px; visibility: hidden; pointer-events: none;">9</div><div class="cm-gutterElement" style="height: 14px;">1</div><div class="cm-gutterElement" style="height: 14px;">2</div><div class="cm-gutterElement" style="height: 14px;">3</div><div class="cm-gutterElement" style="height: 14px;">4</div><div class="cm-gutterElement" style="height: 14px;">5</div><div class="cm-gutterElement" style="height: 14px;">6</div><div class="cm-gutterElement" style="height: 14px;">7</div><div class="cm-gutterElement" style="height: 14px;">8</div></div></div><div spellcheck="false" autocorrect="off" autocapitalize="off" translate="no" contenteditable="false" class="cm-content" role="textbox" aria-multiline="true" style="tab-size: 4;"><div class="cm-line">fn copy_to(v: &amp;Vec&lt;i32&gt;, max: usize) -&gt; Vec&lt;i32&gt; {</div><div class="cm-line">  let mut v2 = Vec::new();</div><div class="cm-line">  for (i, x) in v.iter().enumerate() {</div><div class="cm-line">    if i == max { break; }</div><div class="cm-line">    v2.push(*x);</div><div class="cm-line">  }</div><div class="cm-line">  return v2;</div><div class="cm-line">}</div></div></div></div></div></section><section><h1 class="section-title"><div id="def-section-" class="definition"> References</div></h1><div class="bib-references"><div id="def-weiser1984program" class="definition"><div class="bib-reference"><span class="tex"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord text"><span class="mord">Mark&nbsp;Weiser</span></span></span></span></span></span>. 1981. Program Slicing. <i>Proceedings of the 5th International Conference on Software Engineering. </i></div></div><div id="def-clarke1998ownership" class="definition"><div class="bib-reference"><span class="tex"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord text"><span class="mord">David&nbsp;G.&nbsp;Clarke</span></span></span></span></span></span>, <span class="tex"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord text"><span class="mord">John&nbsp;M.&nbsp;Potter</span></span></span></span></span></span>, and <span class="tex"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord text"><span class="mord">James&nbsp;Noble</span></span></span></span></span></span>. 1998. Ownership Types for Flexible Alias Protection. <i>Proceedings of the 13th ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications. </i></div></div><div id="def-grossman2002region" class="definition"><div class="bib-reference"><span class="tex"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord text"><span class="mord">Dan&nbsp;Grossman</span></span></span></span></span></span>, <span class="tex"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord text"><span class="mord">Greg&nbsp;Morrisett</span></span></span></span></span></span>, <span class="tex"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord text"><span class="mord">Trevor&nbsp;Jim</span></span></span></span></span></span>, <span class="tex"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord text"><span class="mord">Michael&nbsp;Hicks</span></span></span></span></span></span>, <span class="tex"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord text"><span class="mord">Yanling&nbsp;Wang</span></span></span></span></span></span>, and <span class="tex"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord text"><span class="mord">James&nbsp;Cheney</span></span></span></span></span></span>. 2002. Region-Based Memory Management in Cyclone. <i>Proceedings of the ACM SIGPLAN 2002 Conference on Programming Language Design and Implementation. </i></div></div><div id="def-girard1987linear" class="definition"><div class="bib-reference"><span class="tex"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord text"><span class="mord">Jean-Yves&nbsp;Girard</span></span></span></span></span></span>. 1987. Linear logic. <i>Theoretical Computer Science (1). </i></div></div><div id="def-sabelfeld2003language" class="definition"><div class="bib-reference"><span class="tex"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord text"><span class="mord">A.&nbsp;Sabelfeld</span></span></span></span></span></span>, and <span class="tex"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord text"><span class="mord">A.C.&nbsp;Myers</span></span></span></span></span></span>. 2003. Language-based information-flow security. <i>IEEE Journal on Selected Areas in Communications (1). </i></div></div></div></section><div class="logger"></div><div class="portal"></div></div></div><script src="./index.mjs" type="module" async=""></script></body></html>